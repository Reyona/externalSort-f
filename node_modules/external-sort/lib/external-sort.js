/**
 * Created by Cherry on 2016/10/23.
 */
'use strict';

/*dependencies*/
var async = require('async');
var fs = require('fs');
var lineReader = require('line-reader');
var writeLine = require('lei-stream').writeLine;

/*parameter setup*/
var inputFile = './input.txt';
var outputFile = './output.txt';
var sortFolder = './_sort';
var sortFileSize = 100;
var sortFilePaths = [];
var operator = function (a, b) {
    return a - b;
};

/*step1: split and sort data into ordered little files.*/
function splitData(callback) {
    var child = [];
    lineReader.open(inputFile, function (err, reader) {
        if (err) throw err;
        function loopSplit() {
            if (reader.hasNextLine()) {
                reader.nextLine(function (err, data) {
                    try {
                        if (err) throw err;
                        child.push(JSON.parse(data));
                        if (child.length == sortFileSize) {
                            sortAndSave(child, loopSplit);
                        } else {
                            loopSplit();
                        }
                    } catch (e) {
                        reader.close(function (err) {
                            if (err) throw err;
                        });
                    }
                });
            }
            else {
                if (child.length > 0) {
                    sortAndSave(child, function () {
                        loopSplit();
                    });
                } else {
                    callback();
                }
                reader.close(function (err) {
                    if (err) throw  err;
                });
            }
        }

        loopSplit();
    });
}
var sortFileIndex = 1;
function sortAndSave(child, callback) {
    var filePath = sortFolder + '/' + sortFileIndex + '.txt';
    var outputStream = writeLine(filePath,
        {
            cacheLines: 10000
        });
    child.sort(function (a, b) {
        return operator(a, b);
    });
    child.forEach(function (data) {
        outputStream.write(JSON.stringify(data), function () {
        });
    });
    child.splice(0);
    sortFileIndex++;
    outputStream.end(function () {
        sortFilePaths.push(filePath);
        callback();
    });
}

/*step2: merge little files into one.*/
function mergeData(callback) {
    var openSortFiles = [];
    sortFilePaths.forEach(function (filePath) {
        openSortFiles.push(function (callback) {
            lineReader.open(filePath, function (err, reader) {
                if (err) {
                    callback(false, reader);
                }
                else {
                    callback(null, reader);
                }
            });
        });
    });
    async.series(openSortFiles, function (err, result) {
        if (err) throw err;
        var sortFileReaders = result;
        var readSortFiles = [];
        sortFileReaders.forEach(function (reader, index) {
            readSortFiles.push(function (callback) {
                reader.nextLine(function (err, data) {
                    if (err) {
                        callback(false, null);
                    }
                    else {
                        callback(null, {min: JSON.parse(data), index: index});
                    }
                });
            });
        });
        async.series(readSortFiles, function (err, result) {
            if (err) throw err;
            var minsInSortFile = result;
            var outputStream = writeLine(outputFile,
                {
                    cacheLines: 10000
                });

            function mergeLoop() {
                if (minsInSortFile.length < 1) {
                    outputStream.flush();
                    callback();
                    return;
                }
                minsInSortFile.sort(function (a, b) {
                    return operator(a.min, b.min);
                });
                var minInAllData = minsInSortFile[0];
                outputStream.write(JSON.stringify(minInAllData.min));
                minsInSortFile.shift();
                var targetReader = sortFileReaders[minInAllData.index];
                if (!targetReader.hasNextLine()) {
                    targetReader.close(function (err) {
                        if (err) throw  err;
                        mergeLoop();
                    });
                }
                else {
                    targetReader.nextLine(function (err, data) {
                        setImmediate(function () {
                            if (err) throw  err;
                            minsInSortFile.push({min: JSON.parse(data), index: minInAllData.index});
                            mergeLoop();
                        });

                    });
                }
            }

            mergeLoop();

        })
    });
}


/*
 param1 input:    the path of file with data
 param2 oper:     comparing function
 param3 callback: callback function, it has output file path as parameter
 */
function externalSort(input, oper, callback) {
    /*create output folder*/
    fs.exists(sortFolder, function (exists) {
        if (!exists) {
            fs.mkdir(sortFolder, function () {
            });
        }
    });
    if (input != null) {
        inputFile = input;
    }
    if (oper != null) {
        operator = oper;
    }

    async.series([splitData, mergeData], function (err, result) {
        callback(outputFile);
    });
}

module.exports.externalSort = externalSort;